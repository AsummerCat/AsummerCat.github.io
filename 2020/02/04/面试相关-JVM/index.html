<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/%E9%A3%9E%E5%A4%A9%E5%B0%8F%E5%A5%B3%E8%AD%A6_%E8%8A%B1%E8%8A%B1.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/%E9%A3%9E%E5%A4%A9%E5%B0%8F%E5%A5%B3%E8%AD%A6_%E8%8A%B1%E8%8A%B1.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.geekzu.org/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"www.linjingc.top","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="JVM内存模型12345678910111213线程独占   -&gt;本地方法栈  栈 程序计数器线程共享   -&gt;堆  方法区 1.8使用元空间(Metaspace) 栈:  又称方法栈,线程私有的,线程执行方法是都会创建一个栈帧,用来存储局部变量表,操作栈,动态链接,方法出口等信息.调用方法时执行入栈,方法返回式执行出栈.本地方法栈: 与栈类似,也是用来保存执行方法的信息.执行Java"><meta property="og:type" content="article"><meta property="og:title" content="面试相关-JVM"><meta property="og:url" content="http://www.linjingc.top/2020/02/04/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3-JVM/index.html"><meta property="og:site_name" content="emmm读书使我快乐"><meta property="og:description" content="JVM内存模型12345678910111213线程独占   -&gt;本地方法栈  栈 程序计数器线程共享   -&gt;堆  方法区 1.8使用元空间(Metaspace) 栈:  又称方法栈,线程私有的,线程执行方法是都会创建一个栈帧,用来存储局部变量表,操作栈,动态链接,方法出口等信息.调用方法时执行入栈,方法返回式执行出栈.本地方法栈: 与栈类似,也是用来保存执行方法的信息.执行Java"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-02-03T22:45:39.000Z"><meta property="article:modified_time" content="2023-12-06T03:17:10.842Z"><meta property="article:author" content="一只写Bug的猫"><meta property="article:tag" content="jvm"><meta property="article:tag" content="面试相关"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://www.linjingc.top/2020/02/04/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3-JVM/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://www.linjingc.top/2020/02/04/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3-JVM/","path":"2020/02/04/面试相关-JVM/","title":"面试相关-JVM"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>面试相关-JVM | emmm读书使我快乐</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">emmm读书使我快乐</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">1.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile"><span class="nav-number">1.2.</span> <span class="nav-text">volatile</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="一只写Bug的猫" src="/img/WechatIMG230.jpeg"><p class="site-author-name" itemprop="name">一只写Bug的猫</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">857</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">214</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://www.linjingc.top/2020/02/04/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3-JVM/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/WechatIMG230.jpeg"><meta itemprop="name" content="一只写Bug的猫"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="emmm读书使我快乐"><meta itemprop="description" content=""></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="面试相关-JVM | emmm读书使我快乐"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">面试相关-JVM</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-02-03 22:45:39" itemprop="dateCreated datePublished" datetime="2020-02-03T22:45:39Z">2020-02-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-12-06 03:17:10" itemprop="dateModified" datetime="2023-12-06T03:17:10Z">2023-12-06</time> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>7.1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">线程独占   -&gt;本地方法栈  栈 程序计数器</span><br><span class="line">线程共享   -&gt;堆  方法区 1.8使用元空间(Metaspace) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">栈:  又称方法栈,线程私有的,线程执行方法是都会创建一个栈帧,用来存储局部变量表,操作栈,动态链接,方法出口等信息.调用方法时执行入栈,方法返回式执行出栈.</span></span><br><span class="line"></span><br><span class="line"><span class="section">本地方法栈: 与栈类似,也是用来保存执行方法的信息.执行Java方法是使用栈,执行Native方法时使用本地方法栈.</span></span><br><span class="line"></span><br><span class="line"><span class="section">程序计数器: 保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行Native方法时,程序计数器为空.</span></span><br><span class="line"></span><br><span class="line"><span class="section">堆:JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所欲的对象实例都会放在这里,当堆没有可用空间时,会抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回收器进行垃圾的回收管理</span></span><br><span class="line"></span><br><span class="line"><span class="section">方法区:   它用于存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等数据。</span></span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>-&#96;&#96;&#96;</p><ul><li>可见性保证：强制变量的赋值会刷新回主内存，强制变量的读取会从主内存中重新加载，保证不同的线程总是能看到该变量的最新值。</li><li>有序性保证：通过指令重排序保证变量读写的有序性<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### JVM加载顺序</span><br><span class="line"></span><br><span class="line">![JVM加载顺序](/img/<span class="number">2020</span><span class="number">-02</span><span class="number">-03</span>/<span class="number">5.</span>png)</span><br><span class="line"></span><br></pre></td></tr></table></figure>深绿色表示加载过程，浅绿色表示生命周期。</li></ul><p>加载：通过类的完全限定名找到字节码文件，通过字节码文件创建class对象。</p><p>验证：图中始终验证方法。</p><p>准备：为static修饰的变量分配内存，初始值0或者null。（final不分配，因为在编译时已经分配）</p><p>解析：图中。</p><p>初始化：看图中解释，若类的父类没有初始化，则先初始化父类的静态块和静态变量，只有对类的主动使用时才会初始化。</p><p>初始化的出发条件：创建类实例、访问类静态变量或者静态方法、class.forName()发射加载、某个子类被初始化。<br>使用：实例化。</p><p>卸载：java前三种类加载器的加载的类不会被卸载，用户自定义类加载器加载的类才会被卸载。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 类加载器与加载模式</span><br><span class="line"></span><br><span class="line">![JVM加载顺序](/img/<span class="number">2020</span><span class="number">-02</span><span class="number">-03</span>/<span class="number">7.</span>png)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类加载器：启动类加载器、扩展类加载器、应用&#x2F;系统加载器、用户自定义加载器。</p><p>双亲委派模式好处：</p><p>避免类的重复加载；<br>防止java系统类被篡改。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 调优参数</span><br><span class="line"></span><br><span class="line">### JVM的参数类型</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>标配参数 (稳定参数) 例如:查看版本号 -version , -help , java -showversion</p></li><li><p>x参数(了解) 例如: -Xint 解释执行 -Xcomp JIT编译执行 -Xmixed 混合执行</p></li><li><p>xx参数 (重点使用)<br>| boolean类型 : -XX:+或者-属性值 表示开启或关闭某个属性 例如:开启GC日志 使用某个GC回收策略<br>| KV设值类型 : -XX:属性key&#x3D;属性value 例如:-XX:MetaspaceSize&#x3D;128m</p></li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 查看JVM参数初始值和修改</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>使用 jps 查看进程后 再用jinfo -flags 进程号 查看运行的进程JVM参数</p></li><li><p>使用 java -XX:+PrintFlagsInitial 查看初始化默认值 (推荐)</p></li><li><p>使用 java -XX:+PrintFlagsFinal -version 查看修改和更新的内容<br>|java -XX:+PrintFlagsFinal -XX:MetaspaceSize&#x3D;512m 运行类名 -&gt;这是运行时修改</p></li><li><p>使用 java -XX:+PrintCommandLineFlags -version 查看初始值 (主要容易看垃圾回收器)</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 常用JVM参数</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>-Xms 设置初始化内存</p></li><li><p>-Xmx 设置最大内存</p></li><li><p>-Xss 设置线程 栈内存大小 栈深度</p></li><li><p>-Xmn 设置新生代大小</p></li><li><p>-XX:MetaspaceSize 设置元空间大小</p></li><li><p>-XX:PrintGCDetails 显示GC明细日志</p></li><li><p>-XX:SurvivorRatio 设置幸存区比例占比 &#x3D;8 默认8:1:1 新生代默认交换15次晋升老年代</p></li><li><p>-XX:NewRatio 设置老年代的占比大小 &#x3D;2 默认 新生代1老年代2</p></li><li><p>-XX:MaxTenuringThreshold 设置垃圾最大年龄 默认 15次 0-15之间</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 引用 Reference</span><br><span class="line"></span><br><span class="line">### 强引用<span class="number">95</span>%   (打死不被GC)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>强引用 就算出现OOM也不回收对象 无法被垃圾回收<br>强引用指向一个对象<br>意思是: 一个对象赋给一个引用变量</p></li></ol><p>造成java内存泄漏的主要原因之一</p><p>代码:<br>o1 &#x3D;new o1();<br>o2&#x3D;o1<br>GC<br>o2仍存在</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 软引用 (内存不够的情况下 会被GC)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SoftReferrence类实现<br>实现:<br>SoftReferrence<object>o1&#x3D;new SoftReferrence<object>();</object></object></p><p>例如高效缓存 对内存敏感的程序</p><p>内存充足不回收,内存不足会被回收</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 弱引用(只要GC就回收)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只要有GC一律回收</p><p>WeakReferrence类实现</p><p>例如:<br>1.读取大批量本地文件加入缓存 加快查看 软引用弱引用都可以<br>2. mybatis里面缓存部分 大批量的使用软引用和弱引用</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 弱引用-&gt;WeakHashMap(缓存常用)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>弱HashMap<br>WeakHashMap:<br>跟普通的hashMap的区别: key的引用被修改为null 被GC后 键值对会被回收</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 虚引用</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PhantomReference类实现</p><p>形同虚设 不决定对象的生命周期</p><p>必须和引用队列(ReferenceQueue)联合使用<br>回收前 需要放入队列中保存一下</p><p>主要作用: 跟踪对象被垃圾回收的状态<br>只能在GC对象呗finalize以后 回收之后的做进一步处理</p><p>类似Aop的后置通知</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># OOM的理解</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>java.lang.StackOverflowError 栈内存溢出</p><p>java.lang.OutOfMemoryError: java heap space 堆内存溢出</p><p>java.lang.OutOfMemoryError: GC overhead limit exceeded<br>GC时间过长并且回收效率低 98%的时间回收不到2%的堆内存</p><p>java.lang.OutOfMemoryError: Direct buffer memory<br>直接内存不足 电脑内存不足<br>造成原因: netty会出现allocate()导致直接调用堆外内存<br>解决方案: 可修改-XX:maxDirectMemory设置直接内存大小</p><p>java.lang.OutOfMemoryError: unable to create new native thread<br>不能再创建本地线程<br>造成原因: 1.一个进程创建太多线程,超出系统承载上限<br>2.服务器不允许创建这么多线程 linux默认1024线程<br>解决方案: 1.linux修改句柄 扩大创建线程数量<br>| 查看当前用户最大可执行线程数 ulimit -u<br>| 查看系统配置 vim &#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;90-nproc.conf<br>| 添加张三用户的 线程数<br>2.降低引用的线程数</p><p>java.lang.OutOfMemoryError: Metaspace 元空间溢出<br>设置元空间大小 :-XX:Metaspacesize<br>-XX:MaxMetaspacesize</p><p>元空间存放信息:<br>1.虚拟机加载的类信息<br>2.常量池<br>3.静态变量<br>4.即时编译后的代码</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 垃圾回收部分</span><br><span class="line"></span><br><span class="line">### GC区域分块</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分代回收<br>新生代 -&gt; minorGC<br>老年代 -&gt; FUllGC</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 回收算法<span class="number">4</span>种</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>引用记数算法 (不推荐)<br>复制算法 -&gt;新生代<br>标记清除算法 -&gt;老年代<br>标记整理算法 -&gt;老年代<br>标记压缩算法 -&gt;老年代</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### <span class="number">5</span>大垃圾回收器</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Serial 串行化回收 单线程<br>Parallal 并行回收 多线程 适合弱交互 比如科学计算平台<br>CMS 并发标记清除回收 (互联网常用)用户线程和垃圾回收同时进行 对响应时间有要求<br>G1 (1.9默认)分块回收 适用于堆内存很大的情况下 并发回收<br>ZGC (java11)低延迟 停段时间不超过10ms</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 具体实现JVM参数(<span class="number">6</span>大垃圾收集器 )</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.-XX: +UseSerialGC 串行收集器 默认情况下: Serial+SerialOld</p><ol start="2"><li>-XX: +UseParallelGC 并行收集器 1.8默认吞吐量优先 默认情况下: ParallelScavengeGC+ParallelOld<br>上下两个互相激活 开启一个就好了<br>-XX: +UseParallelOldGC 老年代并行收集器<br>-XX:ParallelGCThreads&#x3D;数字N 表示开启多少个GC线程 CPU&gt;8 N&#x3D;5&#x2F;8 CPU&lt;8 N&#x3D;实际</li></ol><p>3.-XX: +UseConcMarkSweepGC CMS收集器 最短停顿时间 推荐使用: ParNew+CMS+ SerialOld(后备)<br>因为是CMS 并发收集-&gt;标记清除 并没有压缩操作 CMS无法处理垃圾的时候启动备用单线程收集器进行阻塞回收<br>可以添加参数-&gt; -XX: CMSFullGCsBeForeCompaction 默认0 (指定多次GC后 进行一次压缩的FULL GC)</p><p>4.-XX: +UseG1GC G1收集器 默认情况下: 标记整理<br>每块1m-32m不等 -XX:G1HeapRegionSize&#x3D;n 可指定分区大小 必须是2的幂<br>默认分为1024个区域,最大可分为2048个分区 ,也就是最大支持64G内存<br>添加了预测时间 用户可以指定期望的停顿时间<br>标记整理 不产生碎片</p><p>5.-XX: +UseParNewGC 新生代并行收集器 默认情况下: ParNew+SerialOld<br>可搭配老年代的CMS收集器</p><ol start="6"><li>SerialOld 老年代串行回收 (不用书写)</li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### G1的参数</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>-XX:UseG1GC 使用GC</p></li><li><p>-XX:G1HeapRegionSize&#x3D;n 设置G1区域大小范围1M-32M</p></li><li><p>-XX:MaxGCPauseMillis&#x3D;n 设置GC最大停顿时间(毫秒) 不保证肯定</p></li><li><p>-XX:InitiatingHeapOccupancyPenrcent&#x3D;n 堆占用多少时候触发GC ,默认 45</p></li><li><p>-XX:ConcGCThreads&#x3D;n 并发GC使用的线程数</p></li><li><p>-XX:G1ReservePercent&#x3D;n 设置作为空闲空间的预留内存百分比 降低目标空间移除的风险 默认 10%</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### GC知识点整理</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>新生代回收器：SerialGC ParNewGc ParallelScavengeGC<br>名称   串行&#x2F;并行&#x2F;并发	回收算法	适用场景 可以与cms配合<br>SerialGC 串行 复制 单cpu 否<br>ParNewGC 并行 复制 多cpu 是<br>ParallelScavengeGC 并行 复制 多cpu且关注吞吐量 否</p></li></ol><p>三种老生代回收器<br>名称   串行&#x2F;并行&#x2F;并发	回收算法	适用场景<br>SerialOldGC 串行 标记整理 单cpu<br>ParNewOldGC 并行 标记整理 多cpu<br>CMS	并发，几乎不会暂停用户线程	标记清除	多cpu且与用户线程共存<br>CMS收集器的优点：并发收集、低停顿</p><p>G1收集器 分块收集 1.9默认的垃圾回收机制<br>G1适合对最大延迟有要求的场合，ZGC适合64位对大内存有要求的场合</p><p>还有一个ZGC收集器 11提供 是一个可伸缩的、低延迟的垃圾收集器<br>停顿时间不会超过10ms<br>停顿时间不会随着堆的增大而增大（不管多大的堆都能保持在10ms以下）<br>可支持几百M，甚至几T的堆大小（最大支持4T）</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 真题</span><br><span class="line"></span><br><span class="line">##  **JDK8中永久代向元空间的转换原因**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1、字符串存在永久代中，容易出现性能问题和内存溢出。</p><p>2、类及方法的信息等比较难确定其大小（比如动态加载类时），因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 编译期会对指令做什么操作?</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>指令重排 优化执行效率<br>如A 和 B 无关 可以调整执行顺序<br>如果 C 必须执行在AB之后 则无法重排</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 什么情况下会造成fullGC</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>新生代晋升<br>老年代空间不足<br>永久代空间不足</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 简单描述下volatile能解决什么问题?</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>强制主内存读写同步，防止指令重排序<br>根据volatile的可见性保证 和有序性保证 读取volatile的内容直接读取到内存里的</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 对象引用有几种?</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>强引用：不会被GC回收<br>弱引用：每次GC都会被回收<br>虚引用：必须和引用兑现联合使用，跟总一个对象被垃圾回收的过程<br>软引用：空间不足会被GC回收</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 使用过哪些JVM调试工具</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JPS -l: 查看java进程</p><p>jstack 进程号: 线程分析工具(堆栈异常分析)</p><p>jinfo -flag printGCDetails 进程号: 获取进程的详细信息 是否开启参数<br>或者 -flags 进程号: 显示所有参数</p><p>jmap -heap 进程ID 获取映射堆快照</p><p>jvisualvm 可视化工具</p><p>jconsole 可视化工具</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## JVM执行模式有几种?</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解释执行 不经过jit直接由解释器解释执行所有字节码 -&gt;字节码翻译成本地码再执行<br>编译执行 判断是否 “热点代码” 是的话直接走JIT编译执行 机器码<br>混合执行 新版本的jvm默认都是采用混合执行模式</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## GC算法的实现和适用场景</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CMS: 以获取最短回收停顿时间为目标的收集器<br>G1: G1适合对最大延迟有要求的场合 可预测停顿<br>ZGC: ZGC适合64位对大内存有要求的场合</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 类加载过程</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加载: 文件加载到JVM<br>验证: 验证 字节码,文件格式,元数据,符号引用<br>准备: 准备类变量的内存<br>解析: 解析 引用替换,字段解析,接口解析,方法解析<br>初始化: 静态块,静态变量<br>使用: 实例化<br>卸载: GC</p><p>Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,只有用户自定义的加载器加载的类才可以被卸.</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## JVM加载类的机制</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>双亲委派机制<br>即加载器加载类时先把请求委托给自己的父类加载器执行,直到顶层的启动类加载器.父类加载器能够完成加载则成功返回,不能则子类加载器才自己尝试加载.<br>优点:<br>1.避免类的重复加载<br>2.避免Java的核心API被篡改</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 什么是垃圾&amp;什么是GC Roots?</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>垃圾:<br>1. 引用不可达 枚举根节点做可达性分析<br>2. 引用计数法</p><p>GC Roots:<br>链路追踪<br>跟踪GC的根节点 从(GC root对象)根节点出发 -&gt;能被遍历到的对象就判断为存活 ,没有遍历到的判断为死亡</p><p>那些对象能成为GC root的对象 :<br>定一个集合的引用作为根节点出发<br>集合为:<br>1.虚拟机栈(栈帧中的局部变量表)中引用的对象 new 对象<br>2.方法区中的类静态属性引用的对象 static<br>3.方法区中常量引用的对象 final<br>4.本地方法栈native引用的对象 unsafe</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## GC收集方式 G1和CMS的区别</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CMS 可能产生内存碎片 算法:标记清除<br>G1 尽可能不产生碎片 可控制预测停顿时间 算法:复制算法 +标记整理</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 生产服务器变慢了 ,诊断思路和性能评估?</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>查看系统负载能力<br>| top命令查看 CPU和内存 及其右上角的load average(负载均衡 1m 10m 15m) 3个数值&#x2F;3*100 &gt;60% 负载重<br>| 执行命令后 按键盘 1 查看具体哪个CPU负载高<br>| 或者执行 uptime 直接查看负载均衡 也是3合1大于60%</li></ol><p>2.查看CPU<br>| vmstat -n 2 3 查看间隔2秒 3次<br>| 具体查看 -procs r:运行和等待CPU时间片的进程数 最大不超过MaxCpuNum 2倍 b:等待资源数 如磁盘io和网络io<br>-cpu us: 用户进程消耗的CPU百分比 大于50%优化程序 sy :内核进程消耗的CPU时间比<br>| 或者 mpstat -P ALL 2 命令 查看所有CPU</p><p>3.查看指定进程使用信息<br>pidstat -u 1(间隔) -p 进程编号 查看指定进程使用CPU的用量分解信息<br>pidstat -p 进程号 -r 2 查看内存情况<br>pidstat -d 1(间隔) -p 进程号 查看磁盘读写情况</p><p>4.内存查看<br>free -m 命令</p><ol start="5"><li>查看磁盘剩余空间<br>df -h 命令 查看剩余空间 (-h表示换算为G)</li></ol><p>6.查看磁盘IO (重点排查对象)<br>iostat -xdk 2 3 命令 查看<br>|rkB&#x2F;s 每秒读取数据量kb<br>|wkB&#x2F;s 每秒写入数据量kb<br>|svctm I&#x2F;O请求的平均服务时间,单位毫秒<br>|await I&#x2F;O请求的平均等待时间.单位毫秒 :值越小,性能越好<br>|%util 一秒中有多少百分比用于I&#x2F;O操作 ,接近100% 表示磁盘带宽跑满 需要优化程序或者增加磁盘<br>|svctm和await的值很接近表示没有I&#x2F;O等待,磁盘性能好<br>|如果await的值远高于svctm的值,则表示I&#x2F;O队列等待太长,表示需要优化程序或者更换更快的磁盘</p><ol start="7"><li>网络IO<br>ifstat -1命令 (没有该命令就下载) 查看各网卡信息</li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 常用的linux命令</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>top 获取整机情况<br>vmstat cpu情况<br>free 查看内存<br>df 查看磁盘<br>iostst 磁盘io<br>ifstat 网络io<br>uptime 查看系统负载</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## CPU占用过高 如何定位?(重点)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.根据 TOP命令 找到CPU占用过高的程序<br>2. 使用ps ef|grep 或者JPS -l 找到后台程序<br>3.定位到具体线程或者代码 命令: ps -mp 进程 -o -THREAD,tid,time (tid:线程id)<br>4.将需要的线程ID转换为16进制格式(小写) 命令 print “%x\n” 有问题的线程ID<br>5.具体检测线程: jstack 进程ID | grep 16进制tid -A60 (获取前60行)</p><pre><code>
</code></pre></div><footer class="post-footer"><div class="post-tags"><a href="/tags/jvm/" rel="tag"># jvm</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/" rel="tag"># 面试相关</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2020/02/04/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3-%E7%BC%93%E5%AD%98/" rel="prev" title="面试相关-缓存"><i class="fa fa-angle-left"></i> 面试相关-缓存</a></div><div class="post-nav-item"><a href="/2020/02/04/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="next" title="面试相关-多线程">面试相关-多线程 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">一只写Bug的猫</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">2.8m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">41:50</span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/AsummerCat/AsmmerCatHexo" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script><script>var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();</script></body></html>